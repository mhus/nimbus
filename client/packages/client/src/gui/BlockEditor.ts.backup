/**
 * Block Editor
 * Shows and edits properties of selected block
 * Two modes: Display (Block-Info) and Edit (Block-Editor)
 */
import {
  AdvancedDynamicTexture,
  Rectangle,
  TextBlock,
  ScrollViewer,
  Control,
  StackPanel,
  Button,
  InputText,
  Checkbox,
  SelectionPanel,
  RadioButton
} from '@babylonjs/gui';
import type { Scene } from '@babylonjs/core';
import type { BlockSelector, SelectedBlock } from '../player/BlockSelector';
import type { ClientRegistry } from '../registry/ClientRegistry';
import type { BlockType, BlockModifier } from '@nimbus-client/core';
import { BlockShape, getBlockEdgeOffsets, setBlockEdgeOffsets } from '@nimbus-client/core';

enum EditorTab {
  BlockInfo = 'info',
  BlockEditor = 'editor',
  BlockList = 'list',
  Changes = 'changes'
}

interface ModifiedBlock {
  position: { x: number; y: number; z: number };
  originalBlockId: number;
  newBlockId: number;
  modifier?: BlockModifier;  // Optional modifier for the block instance
  isNew: boolean;
  isDeleted: boolean;
}

export class BlockEditor {
  private scene: Scene;
  private advancedTexture: AdvancedDynamicTexture;
  private blockSelector: BlockSelector;
  private registry: ClientRegistry;

  private container!: Rectangle;
  private toolbarPanel!: StackPanel;
  private tabButtonsPanel!: StackPanel;
  private contentContainer!: Rectangle;
  private scrollViewer!: ScrollViewer;
  private contentPanel!: StackPanel;

  private isVisible = false;
  private selectedBlock: SelectedBlock | null = null;
  private currentTab: EditorTab = EditorTab.BlockInfo;
  private isEditMode = false;

  // Change tracking
  private modifiedBlocks: Map<string, ModifiedBlock> = new Map();

  // Edit form fields
  private editBlockId!: InputText;
  private editBlockShape!: InputText;
  private editBlockMaterial!: InputText;

  // Modifier fields
  private editModifierShape!: InputText;
  private editModifierDisplayName!: InputText;
  private editModifierTexture!: InputText;
  private editModifierRotation!: InputText;
  private currentModifier: BlockModifier | null = null;

  // Collapsible section states
  private edgeOffsetsExpanded = false;
  private modifierExpanded = false;
  private blockOptionsExpanded = false;

  // Edge offset data (8 corners * 3 values = 24 values)
  private currentEdgeOffsets: number[] | null = null;

  constructor(
    scene: Scene,
    advancedTexture: AdvancedDynamicTexture,
    blockSelector: BlockSelector,
    registry: ClientRegistry
  ) {
    this.scene = scene;
    this.advancedTexture = advancedTexture;
    this.blockSelector = blockSelector;
    this.registry = registry;

    this.createUI();
    this.hide();

    console.log('[BlockEditor] Initialized with tabs and edit mode');
  }

  /**
   * Create editor UI with tabs and toolbar
   */
  private createUI(): void {
    // Main container (right side of screen)
    this.container = new Rectangle('blockEditorContainer');
    this.container.width = '450px';
    this.container.height = 0.85;
    this.container.thickness = 2;
    this.container.color = '#FFFFFF';
    this.container.background = '#000000DD';
    this.container.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;
    this.container.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    this.container.left = -10;
    this.container.isVisible = false;

    // Title
    const title = new TextBlock('editorTitle');
    title.text = 'Block Editor';
    title.color = '#FFFFFF';
    title.fontSize = 20;
    title.height = '35px';
    title.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    title.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    title.paddingTop = 5;
    this.container.addControl(title);

    // Toolbar
    this.createToolbar();

    // Tab buttons
    this.createTabButtons();

    // Content container
    this.contentContainer = new Rectangle('contentContainer');
    this.contentContainer.width = 1;
    this.contentContainer.height = 0.7;
    this.contentContainer.thickness = 0;
    this.contentContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;

    // Scroll viewer for content
    this.scrollViewer = new ScrollViewer('editorScroller');
    this.scrollViewer.width = 1;
    this.scrollViewer.height = 1;
    this.scrollViewer.thickness = 0;

    // Content panel
    this.contentPanel = new StackPanel('editorContent');
    this.contentPanel.width = 1;
    this.contentPanel.paddingLeft = 10;
    this.contentPanel.paddingRight = 10;
    this.contentPanel.paddingTop = 10;
    this.contentPanel.paddingBottom = 10;

    this.scrollViewer.addControl(this.contentPanel);
    this.contentContainer.addControl(this.scrollViewer);
    this.container.addControl(this.contentContainer);

    // Add to advanced texture
    this.advancedTexture.addControl(this.container);
  }

  /**
   * Create toolbar with action buttons
   */
  private createToolbar(): void {
    this.toolbarPanel = new StackPanel('toolbar');
    this.toolbarPanel.isVertical = false;
    this.toolbarPanel.height = '40px';
    this.toolbarPanel.width = 1;
    this.toolbarPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    this.toolbarPanel.top = 35;
    this.toolbarPanel.paddingLeft = 5;
    this.toolbarPanel.paddingRight = 5;

    // Cancel Edit Mode button
    const cancelBtn = this.createToolbarButton('Cancel', '#FF6600');
    cancelBtn.onPointerClickObservable.add(() => this.cancelEditMode());
    this.toolbarPanel.addControl(cancelBtn);

    this.addToolbarSpacer();

    // Apply All button
    const applyAllBtn = this.createToolbarButton('Apply All', '#00AA00');
    applyAllBtn.onPointerClickObservable.add(() => this.applyAll());
    this.toolbarPanel.addControl(applyAllBtn);

    // Revert All button
    const revertAllBtn = this.createToolbarButton('Revert All', '#AA0000');
    revertAllBtn.onPointerClickObservable.add(() => this.revertAll());
    this.toolbarPanel.addControl(revertAllBtn);

    this.addToolbarSpacer();

    // New Block button
    const newBlockBtn = this.createToolbarButton('New Block', '#0088FF');
    newBlockBtn.onPointerClickObservable.add(() => this.createNewBlock());
    this.toolbarPanel.addControl(newBlockBtn);

    this.addToolbarSpacer();

    // Delete Block button
    const deleteBtn = this.createToolbarButton('Delete', '#AA0000');
    deleteBtn.onPointerClickObservable.add(() => this.deleteBlock());
    this.toolbarPanel.addControl(deleteBtn);

    this.container.addControl(this.toolbarPanel);
  }

  /**
   * Create toolbar button
   */
  private createToolbarButton(text: string, color: string): Button {
    const button = Button.CreateSimpleButton('btn_' + text, text);
    button.width = '80px';
    button.height = '30px';
    button.color = '#FFFFFF';
    button.background = color;
    button.thickness = 1;
    button.fontSize = 12;
    return button;
  }

  /**
   * Add spacer to toolbar
   */
  private addToolbarSpacer(): void {
    const spacer = new Rectangle('spacer');
    spacer.width = '5px';
    spacer.height = '30px';
    spacer.thickness = 0;
    this.toolbarPanel.addControl(spacer);
  }

  /**
   * Create tab buttons
   */
  private createTabButtons(): void {
    this.tabButtonsPanel = new StackPanel('tabButtons');
    this.tabButtonsPanel.isVertical = false;
    this.tabButtonsPanel.height = '35px';
    this.tabButtonsPanel.width = 1;
    this.tabButtonsPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    this.tabButtonsPanel.top = 75;
    this.tabButtonsPanel.paddingLeft = 5;

    // Block Info Tab
    const infoBtn = this.createTabButton('Block Info', EditorTab.BlockInfo);
    this.tabButtonsPanel.addControl(infoBtn);

    // Block Editor Tab
    const editorBtn = this.createTabButton('Block Editor', EditorTab.BlockEditor);
    this.tabButtonsPanel.addControl(editorBtn);

    // Block Type List Tab
    const listBtn = this.createTabButton('Block-Type Liste', EditorTab.BlockList);
    this.tabButtonsPanel.addControl(listBtn);

    // Changes Tab
    const changesBtn = this.createTabButton('Änderungen', EditorTab.Changes);
    this.tabButtonsPanel.addControl(changesBtn);

    this.container.addControl(this.tabButtonsPanel);
  }

  /**
   * Create tab button
   */
  private createTabButton(text: string, tab: EditorTab): Button {
    const button = Button.CreateSimpleButton('tab_' + tab, text);
    button.width = '110px';
    button.height = '30px';
    button.color = '#FFFFFF';
    button.background = this.currentTab === tab ? '#005500' : '#003300';
    button.thickness = 1;
    button.fontSize = 12;

    button.onPointerClickObservable.add(() => {
      this.switchTab(tab);
    });

    return button;
  }

  /**
   * Switch to different tab
   */
  private switchTab(tab: EditorTab): void {
    this.currentTab = tab;
    this.refreshTabButtons();
    this.refreshContent();
  }

  /**
   * Refresh tab button colors
   */
  private refreshTabButtons(): void {
    // Update all tab button backgrounds
    for (let i = 0; i < this.tabButtonsPanel.children.length; i++) {
      const child = this.tabButtonsPanel.children[i];
      if (child instanceof Button) {
        const tabName = child.name.replace('tab_', '');
        child.background = this.currentTab === tabName ? '#005500' : '#003300';
      }
    }
  }

  /**
   * Activate edit mode (switch to Block Editor tab)
   */
  activateEditMode(): void {
    if (!this.isVisible || !this.selectedBlock) return;

    this.isEditMode = true;
    this.switchTab(EditorTab.BlockEditor);
    console.log('[BlockEditor] Edit mode activated');
  }

  /**
   * Cancel edit mode (switch back to Block Info)
   */
  private cancelEditMode(): void {
    this.isEditMode = false;
    this.switchTab(EditorTab.BlockInfo);
    console.log('[BlockEditor] Edit mode cancelled');
  }

  /**
   * Create new block
   */
  createNewBlock(): void {
    console.log('[BlockEditor] Creating new block...');
    // TODO: Implement new block creation
    this.switchTab(EditorTab.BlockEditor);
  }

  /**
   * Delete current block
   */
  private deleteBlock(): void {
    if (!this.selectedBlock) return;
    console.log('[BlockEditor] Deleting block...');
    // TODO: Implement block deletion
  }

  /**
   * Apply all changes
   */
  private applyAll(): void {
    console.log('[BlockEditor] Applying all changes...', this.modifiedBlocks.size, 'blocks');
    // TODO: Send changes to server
  }

  /**
   * Revert all changes
   */
  private revertAll(): void {
    console.log('[BlockEditor] Reverting all changes...');
    this.modifiedBlocks.clear();
    this.refreshContent();
    // TODO: Reload affected chunks from server
  }

  /**
   * Track modification for current block
   */
  private trackBlockModification(newBlockId: number): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;

    // Check if already tracked
    const existing = this.modifiedBlocks.get(key);

    if (!existing) {
      // New modification
      this.modifiedBlocks.set(key, {
        position: {
          x: this.selectedBlock.blockX,
          y: this.selectedBlock.blockY,
          z: this.selectedBlock.blockZ,
        },
        originalBlockId: this.selectedBlock.blockId,
        newBlockId: newBlockId,
        isNew: false,
        isDeleted: false,
      });
    } else {
      // Update existing modification
      existing.newBlockId = newBlockId;
    }

    console.log(`[BlockEditor] Tracked modification at ${key}: ${this.selectedBlock.blockId} -> ${newBlockId}`);

    // Refresh display to show modified count
    this.refreshContent();
  }

  /**
   * Revert single block
   */
  private revertBlock(): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;

    if (this.modifiedBlocks.has(key)) {
      this.modifiedBlocks.delete(key);
      console.log(`[BlockEditor] Reverted block at ${key}`);
      this.refreshContent();
    }
  }

  /**
   * Show editor
   */
  show(): void {
    if (this.isVisible) return;

    this.container.isVisible = true;
    this.isVisible = true;
    this.update();
  }

  /**
   * Hide editor
   */
  hide(): void {
    if (!this.isVisible) return;

    this.container.isVisible = false;
    this.isVisible = false;
  }

  /**
   * Toggle editor visibility
   */
  toggle(): void {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Check if editor is visible
   */
  getIsVisible(): boolean {
    return this.isVisible;
  }

  /**
   * Update editor content
   */
  update(): void {
    if (!this.isVisible) return;

    const selected = this.blockSelector.getSelectedBlock();

    if (this.hasSelectionChanged(selected)) {
      this.selectedBlock = selected;
      this.refreshContent();
    }
  }

  /**
   * Check if selection has changed
   */
  private hasSelectionChanged(newSelection: SelectedBlock | null): boolean {
    if (!this.selectedBlock && !newSelection) return false;
    if (!this.selectedBlock || !newSelection) return true;

    return (
      this.selectedBlock.blockX !== newSelection.blockX ||
      this.selectedBlock.blockY !== newSelection.blockY ||
      this.selectedBlock.blockZ !== newSelection.blockZ ||
      this.selectedBlock.blockId !== newSelection.blockId
    );
  }

  /**
   * Refresh editor content based on current tab
   */
  private refreshContent(): void {
    this.contentPanel.clearControls();

    switch (this.currentTab) {
      case EditorTab.BlockInfo:
        this.renderBlockInfo();
        break;
      case EditorTab.BlockEditor:
        this.renderBlockEditor();
        break;
      case EditorTab.BlockList:
        this.renderBlockList();
        break;
      case EditorTab.Changes:
        this.renderChanges();
        break;
    }
  }

  /**
   * Render Block Info tab (read-only)
   */
  private renderBlockInfo(): void {
    if (!this.selectedBlock) {
      this.addText('No block selected', '#888888');
      this.addText('Enable selection mode with "select on"', '#888888', 12);
      return;
    }

    const blockType = this.registry.getBlockByID(this.selectedBlock.blockId);

    if (!blockType) {
      this.addText(`Unknown block ID: ${this.selectedBlock.blockId}`, '#FF0000');
      return;
    }

    // Display block information (read-only)
    this.addSectionTitle('Block Information');
    this.addProperty('Position', `(${this.selectedBlock.blockX}, ${this.selectedBlock.blockY}, ${this.selectedBlock.blockZ})`);
    this.addProperty('Distance', `${this.selectedBlock.distance.toFixed(2)} blocks`);
    this.addSpacer();

    this.addSectionTitle('Block Type');
    this.addProperty('ID', `${blockType.id}`);
    this.addProperty('Name', blockType.name);
    if (blockType.displayName) {
      this.addProperty('Display Name', blockType.displayName);
    }
    this.addSpacer();

    this.addSectionTitle('Rendering');
    this.addProperty('Shape', this.getShapeName(blockType.shape));
    this.addProperty('Texture', this.getTextureInfo(blockType.texture));
    this.addProperty('Transparent', blockType.transparent ? 'Yes' : 'No');
    this.addProperty('Solid', blockType.solid !== false ? 'Yes' : 'No');
    this.addSpacer();

    if (blockType.options) {
      this.addSectionTitle('Block Options');
      if (blockType.options.material) {
        this.addProperty('Material', blockType.options.material);
      }
      if (blockType.options.fluid) {
        this.addProperty('Fluid', 'Yes');
      }
    }
  }

  /**
   * Render Block Editor tab (editable form)
   */
  private renderBlockEditor(): void {
    if (!this.selectedBlock) {
      this.addText('No block selected', '#888888');
      this.addText('Select a block or press "," to create new', '#888888', 12);
      return;
    }

    const blockType = this.registry.getBlockByID(this.selectedBlock.blockId);

    if (!blockType) {
      this.addText(`Unknown block ID: ${this.selectedBlock.blockId}`, '#FF0000');
      return;
    }

    // Editable form
    this.addSectionTitle('Block Editor (Editable)');

    // Position (read-only)
    this.addProperty('Position (read-only)', `(${this.selectedBlock.blockX}, ${this.selectedBlock.blockY}, ${this.selectedBlock.blockZ})`);
    this.addSpacer();

    // Block ID input
    this.addLabel('Block ID:');
    this.editBlockId = this.addInputField(`${blockType.id}`, (newValue) => {
      const newBlockId = parseInt(newValue);
      if (!isNaN(newBlockId)) {
        this.trackBlockModification(newBlockId);
      }
    });

    // Shape input (for display - not yet functional)
    this.addLabel('Shape:');
    this.editBlockShape = this.addInputField(this.getShapeName(blockType.shape));

    // Material input (for display - not yet functional)
    this.addLabel('Material:');
    this.editBlockMaterial = this.addInputField(blockType.options?.material || 'none');

    this.addSpacer();

    // Modifier section
    this.addSectionTitle('Block-Instance Modifiers');
    this.addText('Override properties for this specific block instance', '#888888', 11);
    this.addSpacer();

    // Get existing modifier for this block (if tracked)
    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
    const tracked = this.modifiedBlocks.get(key);
    this.currentModifier = tracked?.modifier || null;

    // Display Name modifier
    this.addLabel('Override Display Name:');
    this.editModifierDisplayName = this.addInputField(
      this.currentModifier?.displayName || '',
      (newValue) => {
        this.updateModifier('displayName', newValue || undefined);
      }
    );

    // Shape modifier
    this.addLabel('Override Shape (CUBE/CROSS/SPHERE/etc):');
    this.editModifierShape = this.addInputField(
      this.currentModifier?.shape !== undefined ? this.getShapeName(this.currentModifier.shape) : '',
      (newValue) => {
        const shape = this.parseShapeName(newValue);
        this.updateModifier('shape', shape);
      }
    );

    // Texture modifier
    this.addLabel('Override Texture Path:');
    this.editModifierTexture = this.addInputField(
      this.currentModifier?.texture ? (Array.isArray(this.currentModifier.texture) ? this.currentModifier.texture.join(',') : this.currentModifier.texture) : '',
      (newValue) => {
        this.updateModifier('texture', newValue || undefined);
      }
    );

    // Rotation modifier
    this.addLabel('Rotation (0-360 degrees):');
    this.editModifierRotation = this.addInputField(
      this.currentModifier?.rotation !== undefined ? this.currentModifier.rotation.toString() : '',
      (newValue) => {
        const rotation = parseFloat(newValue);
        this.updateModifier('rotation', !isNaN(rotation) ? rotation : undefined);
      }
    );

    this.addSpacer();

    // Clear modifier button
    const clearModifierBtn = Button.CreateSimpleButton('clearModifier', 'Clear All Modifiers');
    clearModifierBtn.width = 1;
    clearModifierBtn.height = '30px';
    clearModifierBtn.color = '#FFFFFF';
    clearModifierBtn.background = '#886600';
    clearModifierBtn.thickness = 1;
    clearModifierBtn.fontSize = 13;
    clearModifierBtn.onPointerClickObservable.add(() => this.clearModifier());
    this.contentPanel.addControl(clearModifierBtn);

    this.addSpacer();

    // Revert Block button
    const revertBtn = Button.CreateSimpleButton('revertBlock', 'Revert This Block');
    revertBtn.width = 1;
    revertBtn.height = '30px';
    revertBtn.color = '#FFFFFF';
    revertBtn.background = '#AA0000';
    revertBtn.thickness = 1;
    revertBtn.fontSize = 13;
    revertBtn.onPointerClickObservable.add(() => this.revertBlock());
    this.contentPanel.addControl(revertBtn);

    this.addSpacer();
    this.addText('Changes are tracked live', '#00FF00', 11);
    this.addText(`Modified blocks: ${this.modifiedBlocks.size}`, '#FFFF00', 11);
  }

  /**
   * Render Block Type List tab
   */
  private renderBlockList(): void {
    this.addSectionTitle('All Registered Block-Types');

    const allBlocks = this.registry.getAllBlocks();

    if (allBlocks.length === 0) {
      this.addText('No block types registered', '#888888');
      return;
    }

    // Header
    this.addText('ID | Name | Shape | Material', '#00FF00', 12);
    this.addSpacer();

    // List all blocks
    for (const block of allBlocks) {
      const shape = this.getShapeName(block.shape);
      const material = block.options?.material || '-';
      this.addText(`${block.id} | ${block.name} | ${shape} | ${material}`, '#FFFFFF', 11);
    }
  }

  /**
   * Render Changes tab (modified block instances)
   */
  private renderChanges(): void {
    this.addSectionTitle('Modified Block-Instances');

    if (this.modifiedBlocks.size === 0) {
      this.addText('No changes pending', '#888888');
      this.addText('Edit blocks in the Block Editor tab', '#888888', 12);
      return;
    }

    this.addText(`Total changes: ${this.modifiedBlocks.size}`, '#FFFF00', 14);
    this.addSpacer();

    // Header
    this.addText('Position | Original → New | Status', '#00FF00', 12);
    this.addSpacer();

    // List all modified blocks
    for (const [key, modified] of this.modifiedBlocks.entries()) {
      const pos = `(${modified.position.x}, ${modified.position.y}, ${modified.position.z})`;

      // Get block type names
      const originalType = this.registry.getBlockByID(modified.originalBlockId);
      const newType = this.registry.getBlockByID(modified.newBlockId);

      const originalName = originalType ? originalType.name : `ID ${modified.originalBlockId}`;
      const newName = newType ? newType.name : `ID ${modified.newBlockId}`;

      // Status
      let status = 'Modified';
      let color = '#FFAA00';
      if (modified.isNew) {
        status = 'New';
        color = '#00FF00';
      } else if (modified.isDeleted) {
        status = 'Deleted';
        color = '#FF0000';
      }

      // Display line
      this.addText(`${pos}`, '#AAAAAA', 11);
      this.addText(`  ${originalName} → ${newName}`, '#FFFFFF', 11);
      this.addText(`  Status: ${status}`, color, 11);
      this.addSpacer();
    }

    // Action buttons
    const applyBtn = Button.CreateSimpleButton('applyChanges', 'Apply All Changes');
    applyBtn.width = 1;
    applyBtn.height = '35px';
    applyBtn.color = '#FFFFFF';
    applyBtn.background = '#00AA00';
    applyBtn.thickness = 1;
    applyBtn.fontSize = 14;
    applyBtn.onPointerClickObservable.add(() => this.applyAll());
    this.contentPanel.addControl(applyBtn);

    this.addSpacer();

    const revertBtn = Button.CreateSimpleButton('revertChanges', 'Revert All Changes');
    revertBtn.width = 1;
    revertBtn.height = '35px';
    revertBtn.color = '#FFFFFF';
    revertBtn.background = '#AA0000';
    revertBtn.thickness = 1;
    revertBtn.fontSize = 14;
    revertBtn.onPointerClickObservable.add(() => this.revertAll());
    this.contentPanel.addControl(revertBtn);
  }

  /**
   * Add label
   */
  private addLabel(text: string): void {
    const label = new TextBlock();
    label.text = text;
    label.color = '#AAAAAA';
    label.fontSize = 13;
    label.height = '20px';
    label.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    label.paddingTop = 5;
    this.contentPanel.addControl(label);
  }

  /**
   * Add input field with change tracking
   */
  private addInputField(value: string, onChange?: (newValue: string) => void): InputText {
    const input = new InputText();
    input.width = 1;
    input.height = '30px';
    input.color = '#FFFFFF';
    input.background = '#333333';
    input.text = value;
    input.fontSize = 13;
    input.thickness = 1;
    input.paddingLeft = 5;

    // Add change listener if provided
    if (onChange) {
      input.onTextChangedObservable.add(() => {
        onChange(input.text);
      });
    }

    this.contentPanel.addControl(input);
    return input;
  }

  /**
   * Get shape name from shape enum value
   */
  private getShapeName(shape: number): string {
    const shapes = ['CUBE', 'CROSS', 'HASH', 'MODEL', 'GLASS', 'FLAT', 'SPHERE', 'COLUMN', 'ROUND_CUBE'];
    return shapes[shape] || `Unknown (${shape})`;
  }

  /**
   * Get texture info string
   */
  private getTextureInfo(texture: string | string[]): string {
    if (Array.isArray(texture)) {
      return texture.length === 1 ? texture[0] : `Array (${texture.length} textures)`;
    }
    return texture;
  }

  /**
   * Add section title
   */
  private addSectionTitle(text: string): void {
    const title = new TextBlock();
    title.text = text;
    title.color = '#00FF00';
    title.fontSize = 16;
    title.height = '30px';
    title.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    title.paddingTop = 5;
    this.contentPanel.addControl(title);
  }

  /**
   * Add property row
   */
  private addProperty(label: string, value: string): void {
    const text = new TextBlock();
    text.text = `  ${label}: ${value}`;
    text.color = '#FFFFFF';
    text.fontSize = 14;
    text.height = '25px';
    text.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    text.textWrapping = true;
    text.resizeToFit = true;
    this.contentPanel.addControl(text);
  }

  /**
   * Add simple text
   */
  private addText(text: string, color: string = '#FFFFFF', fontSize: number = 14): void {
    const textBlock = new TextBlock();
    textBlock.text = text;
    textBlock.color = color;
    textBlock.fontSize = fontSize;
    textBlock.height = '25px';
    textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    textBlock.textWrapping = true;
    textBlock.resizeToFit = true;
    this.contentPanel.addControl(textBlock);
  }

  /**
   * Add spacer
   */
  private addSpacer(): void {
    const spacer = new TextBlock();
    spacer.text = '';
    spacer.height = '10px';
    this.contentPanel.addControl(spacer);
  }

  /**
   * Update modifier property
   */
  private updateModifier(property: keyof BlockModifier, value: any): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
    let tracked = this.modifiedBlocks.get(key);

    // Initialize tracked block if not exists
    if (!tracked) {
      tracked = {
        position: {
          x: this.selectedBlock.blockX,
          y: this.selectedBlock.blockY,
          z: this.selectedBlock.blockZ,
        },
        originalBlockId: this.selectedBlock.blockId,
        newBlockId: this.selectedBlock.blockId,
        isNew: false,
        isDeleted: false,
      };
      this.modifiedBlocks.set(key, tracked);
    }

    // Initialize modifier if not exists
    if (!tracked.modifier) {
      tracked.modifier = {};
    }

    // Update modifier property
    if (value === undefined) {
      delete tracked.modifier[property];
    } else {
      (tracked.modifier as any)[property] = value;
    }

    // Update current modifier reference
    this.currentModifier = tracked.modifier;

    console.log(`[BlockEditor] Updated modifier.${property} = ${value} for block at ${key}`);
    this.refreshContent();
  }

  /**
   * Clear all modifiers for current block
   */
  private clearModifier(): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
    const tracked = this.modifiedBlocks.get(key);

    if (tracked) {
      tracked.modifier = undefined;
      this.currentModifier = null;
      console.log(`[BlockEditor] Cleared modifiers for block at ${key}`);
      this.refreshContent();
    }
  }

  /**
   * Parse shape name to shape enum value
   */
  private parseShapeName(shapeName: string): number | undefined {
    if (!shapeName) return undefined;

    const shapeMap: { [key: string]: number } = {
      'CUBE': 0,
      'CROSS': 1,
      'HASH': 2,
      'MODEL': 3,
      'GLASS': 4,
      'FLAT': 5,
      'SPHERE': 6,
      'COLUMN': 7,
      'ROUND_CUBE': 8,
    };

    const normalized = shapeName.toUpperCase().trim();
    return shapeMap[normalized];
  }

  /**
   * Add dropdown selector
   */
  private addDropdown(options: string[], selectedValue: string, onChange: (newValue: string) => void): void {
    const dropdown = new SelectionPanel('dropdown');
    dropdown.width = 1;
    dropdown.height = '30px';
    dropdown.color = '#FFFFFF';
    dropdown.background = '#333333';
    dropdown.thickness = 1;

    // Add options (Simplified - using buttons since SelectionPanel is complex)
    // TODO: Implement proper dropdown with SelectionPanel
    const buttonContainer = new StackPanel();
    buttonContainer.isVertical = false;
    buttonContainer.width = 1;
    buttonContainer.height = '30px';

    for (const option of options.slice(0, 3)) { // Show first 3 options
      const btn = Button.CreateSimpleButton('opt_' + option, option);
      btn.width = '100px';
      btn.height = '28px';
      btn.color = option === selectedValue ? '#00FF00' : '#FFFFFF';
      btn.background = option === selectedValue ? '#003300' : '#222222';
      btn.fontSize = 11;
      btn.onPointerClickObservable.add(() => onChange(option));
      buttonContainer.addControl(btn);
    }

    this.contentPanel.addControl(buttonContainer);
  }

  /**
   * Add checkbox
   */
  private addCheckbox(label: string, checked: boolean, onChange: (value: boolean) => void): Checkbox {
    const container = new StackPanel();
    container.isVertical = false;
    container.width = 1;
    container.height = '30px';

    const checkbox = new Checkbox();
    checkbox.width = '20px';
    checkbox.height = '20px';
    checkbox.isChecked = checked;
    checkbox.color = '#FFFFFF';
    checkbox.background = '#333333';
    checkbox.onIsCheckedChangedObservable.add((value) => onChange(value));

    const labelText = new TextBlock();
    labelText.text = label;
    labelText.color = '#FFFFFF';
    labelText.fontSize = 13;
    labelText.width = 0.9;
    labelText.height = '30px';
    labelText.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    labelText.paddingLeft = 10;

    container.addControl(checkbox);
    container.addControl(labelText);
    this.contentPanel.addControl(container);

    return checkbox;
  }

  /**
   * Add collapsible section header
   */
  private addCollapsibleHeader(title: string, isExpanded: boolean, onToggle: () => void): void {
    const header = Button.CreateSimpleButton('header_' + title, (isExpanded ? '▼ ' : '▶ ') + title);
    header.width = 1;
    header.height = '35px';
    header.color = '#FFFF00';
    header.background = '#004400';
    header.thickness = 1;
    header.fontSize = 14;
    header.fontWeight = 'bold';
    header.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.paddingLeft = 10;
    header.onPointerClickObservable.add(onToggle);
    this.contentPanel.addControl(header);
  }

  /**
   * Add number input (for floats/ints with range)
   */
  private addNumberInput(label: string, value: number | undefined, min: number, max: number, onChange: (value: number | undefined) => void): void {
    this.addLabel(label);
    const input = this.addInputField(
      value !== undefined ? value.toString() : '',
      (newValue) => {
        if (newValue === '') {
          onChange(undefined);
        } else {
          const num = parseFloat(newValue);
          if (!isNaN(num)) {
            const clamped = Math.max(min, Math.min(max, num));
            onChange(clamped);
          }
        }
      }
    );
  }

  /**
   * Dispose editor
   */
  dispose(): void {
    this.container.dispose();
  }
}
