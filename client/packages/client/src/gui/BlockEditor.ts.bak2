/**
 * Block Editor
 * Shows and edits properties of selected block
 * Two modes: Display (Block-Info) and Edit (Block-Editor)
 */
import {
  AdvancedDynamicTexture,
  Rectangle,
  TextBlock,
  ScrollViewer,
  Control,
  StackPanel,
  Button,
  InputText,
  Checkbox,
  SelectionPanel,
  RadioButton
} from '@babylonjs/gui';
import type { Scene } from '@babylonjs/core';
import type { BlockSelector, SelectedBlock } from '../player/BlockSelector';
import type { ClientRegistry } from '../registry/ClientRegistry';
import type { BlockType, BlockModifier } from '@voxel-02/core';
import { BlockShape, getBlockEdgeOffsets, setBlockEdgeOffsets } from '@voxel-02/core';

enum EditorTab {
  BlockInfo = 'info',
  BlockEditor = 'editor',
  BlockList = 'list',
  Changes = 'changes'
}

interface ModifiedBlock {
  position: { x: number; y: number; z: number };
  originalBlockId: number;
  newBlockId: number;
  modifier?: BlockModifier;  // Optional modifier for the block instance
  isNew: boolean;
  isDeleted: boolean;
}

export class BlockEditor {
  private scene: Scene;
  private advancedTexture: AdvancedDynamicTexture;
  private blockSelector: BlockSelector;
  private registry: ClientRegistry;

  private container!: Rectangle;
  private toolbarPanel!: StackPanel;
  private tabButtonsPanel!: StackPanel;
  private contentContainer!: Rectangle;
  private scrollViewer!: ScrollViewer;
  private contentPanel!: StackPanel;

  private isVisible = false;
  private selectedBlock: SelectedBlock | null = null;
  private currentTab: EditorTab = EditorTab.BlockInfo;
  private isEditMode = false;

  // Change tracking
  private modifiedBlocks: Map<string, ModifiedBlock> = new Map();

  // Edit form fields
  private editBlockId!: InputText;
  private editBlockShape!: InputText;
  private editBlockMaterial!: InputText;

  // Modifier fields
  private editModifierShape!: InputText;
  private editModifierDisplayName!: InputText;
  private editModifierTexture!: InputText;
  private editModifierRotation!: InputText;
  private currentModifier: BlockModifier | null = null;

  // Collapsible section states
  private edgeOffsetsExpanded = false;
  private modifierExpanded = false;
  private blockOptionsExpanded = false;

  // Edge offset data (8 corners * 3 values = 24 values)
  private currentEdgeOffsets: number[] | null = null;

  constructor(
    scene: Scene,
    advancedTexture: AdvancedDynamicTexture,
    blockSelector: BlockSelector,
    registry: ClientRegistry
  ) {
    this.scene = scene;
    this.advancedTexture = advancedTexture;
    this.blockSelector = blockSelector;
    this.registry = registry;

    this.createUI();
    this.hide();

    console.log('[BlockEditor] Initialized with tabs and edit mode');
  }

  /**
   * Create editor UI with tabs and toolbar
   */
  private createUI(): void {
    // Main container (right side of screen)
    this.container = new Rectangle('blockEditorContainer');
    this.container.width = '450px';
    this.container.height = 0.85;
    this.container.thickness = 2;
    this.container.color = '#FFFFFF';
    this.container.background = '#000000DD';
    this.container.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;
    this.container.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    this.container.left = -10;
    this.container.isVisible = false;

    // Title
    const title = new TextBlock('editorTitle');
    title.text = 'Block Editor';
    title.color = '#FFFFFF';
    title.fontSize = 20;
    title.height = '35px';
    title.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    title.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    title.paddingTop = 5;
    this.container.addControl(title);

    // Toolbar
    this.createToolbar();

    // Tab buttons
    this.createTabButtons();

    // Content container
    this.contentContainer = new Rectangle('contentContainer');
    this.contentContainer.width = 1;
    this.contentContainer.height = 0.7;
    this.contentContainer.thickness = 0;
    this.contentContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;

    // Scroll viewer for content
    this.scrollViewer = new ScrollViewer('editorScroller');
    this.scrollViewer.width = 1;
    this.scrollViewer.height = 1;
    this.scrollViewer.thickness = 0;

    // Content panel
    this.contentPanel = new StackPanel('editorContent');
    this.contentPanel.width = 1;
    this.contentPanel.paddingLeft = 10;
    this.contentPanel.paddingRight = 10;
    this.contentPanel.paddingTop = 10;
    this.contentPanel.paddingBottom = 10;

    this.scrollViewer.addControl(this.contentPanel);
    this.contentContainer.addControl(this.scrollViewer);
    this.container.addControl(this.contentContainer);

    // Add to advanced texture
    this.advancedTexture.addControl(this.container);
  }

  /**
   * Create toolbar with action buttons
   */
  private createToolbar(): void {
    this.toolbarPanel = new StackPanel('toolbar');
    this.toolbarPanel.isVertical = false;
    this.toolbarPanel.height = '40px';
    this.toolbarPanel.width = 1;
    this.toolbarPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    this.toolbarPanel.top = 35;
    this.toolbarPanel.paddingLeft = 5;
    this.toolbarPanel.paddingRight = 5;

    // Cancel Edit Mode button
    const cancelBtn = this.createToolbarButton('Cancel', '#FF6600');
    cancelBtn.onPointerClickObservable.add(() => this.cancelEditMode());
    this.toolbarPanel.addControl(cancelBtn);

    this.addToolbarSpacer();

    // Apply All button
    const applyAllBtn = this.createToolbarButton('Apply All', '#00AA00');
    applyAllBtn.onPointerClickObservable.add(() => this.applyAll());
    this.toolbarPanel.addControl(applyAllBtn);

    // Revert All button
    const revertAllBtn = this.createToolbarButton('Revert All', '#AA0000');
    revertAllBtn.onPointerClickObservable.add(() => this.revertAll());
    this.toolbarPanel.addControl(revertAllBtn);

    this.addToolbarSpacer();

    // New Block button
    const newBlockBtn = this.createToolbarButton('New Block', '#0088FF');
    newBlockBtn.onPointerClickObservable.add(() => this.createNewBlock());
    this.toolbarPanel.addControl(newBlockBtn);

    this.addToolbarSpacer();

    // Delete Block button
    const deleteBtn = this.createToolbarButton('Delete', '#AA0000');
    deleteBtn.onPointerClickObservable.add(() => this.deleteBlock());
    this.toolbarPanel.addControl(deleteBtn);

    this.container.addControl(this.toolbarPanel);
  }

  /**
   * Create toolbar button
   */
  private createToolbarButton(text: string, color: string): Button {
    const button = Button.CreateSimpleButton('btn_' + text, text);
    button.width = '80px';
    button.height = '30px';
    button.color = '#FFFFFF';
    button.background = color;
    button.thickness = 1;
    button.fontSize = 12;
    return button;
  }

  /**
   * Add spacer to toolbar
   */
  private addToolbarSpacer(): void {
    const spacer = new Rectangle('spacer');
    spacer.width = '5px';
    spacer.height = '30px';
    spacer.thickness = 0;
    this.toolbarPanel.addControl(spacer);
  }

  /**
   * Create tab buttons
   */
  private createTabButtons(): void {
    this.tabButtonsPanel = new StackPanel('tabButtons');
    this.tabButtonsPanel.isVertical = false;
    this.tabButtonsPanel.height = '35px';
    this.tabButtonsPanel.width = 1;
    this.tabButtonsPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    this.tabButtonsPanel.top = 75;
    this.tabButtonsPanel.paddingLeft = 5;

    // Block Info Tab
    const infoBtn = this.createTabButton('Block Info', EditorTab.BlockInfo);
    this.tabButtonsPanel.addControl(infoBtn);

    // Block Editor Tab
    const editorBtn = this.createTabButton('Block Editor', EditorTab.BlockEditor);
    this.tabButtonsPanel.addControl(editorBtn);

    // Block Type List Tab
    const listBtn = this.createTabButton('Block-Type Liste', EditorTab.BlockList);
    this.tabButtonsPanel.addControl(listBtn);

    // Changes Tab
    const changesBtn = this.createTabButton('Änderungen', EditorTab.Changes);
    this.tabButtonsPanel.addControl(changesBtn);

    this.container.addControl(this.tabButtonsPanel);
  }

  /**
   * Create tab button
   */
  private createTabButton(text: string, tab: EditorTab): Button {
    const button = Button.CreateSimpleButton('tab_' + tab, text);
    button.width = '110px';
    button.height = '30px';
    button.color = '#FFFFFF';
    button.background = this.currentTab === tab ? '#005500' : '#003300';
    button.thickness = 1;
    button.fontSize = 12;

    button.onPointerClickObservable.add(() => {
      this.switchTab(tab);
    });

    return button;
  }

  /**
   * Switch to different tab
   */
  private switchTab(tab: EditorTab): void {
    this.currentTab = tab;
    this.refreshTabButtons();
    this.refreshContent();
  }

  /**
   * Refresh tab button colors
   */
  private refreshTabButtons(): void {
    // Update all tab button backgrounds
    for (let i = 0; i < this.tabButtonsPanel.children.length; i++) {
      const child = this.tabButtonsPanel.children[i];
      if (child instanceof Button) {
        const tabName = child.name.replace('tab_', '');
        child.background = this.currentTab === tabName ? '#005500' : '#003300';
      }
    }
  }

  /**
   * Activate edit mode (switch to Block Editor tab)
   */
  activateEditMode(): void {
    if (!this.isVisible || !this.selectedBlock) return;

    this.isEditMode = true;
    this.switchTab(EditorTab.BlockEditor);
    console.log('[BlockEditor] Edit mode activated');
  }

  /**
   * Cancel edit mode (switch back to Block Info)
   */
  private cancelEditMode(): void {
    this.isEditMode = false;
    this.switchTab(EditorTab.BlockInfo);
    console.log('[BlockEditor] Edit mode cancelled');
  }

  /**
   * Create new block
   */
  createNewBlock(): void {
    console.log('[BlockEditor] Creating new block...');
    // TODO: Implement new block creation
    this.switchTab(EditorTab.BlockEditor);
  }

  /**
   * Delete current block
   */
  private deleteBlock(): void {
    if (!this.selectedBlock) return;
    console.log('[BlockEditor] Deleting block...');
    // TODO: Implement block deletion
  }

  /**
   * Apply all changes
   */
  private applyAll(): void {
    console.log('[BlockEditor] Applying all changes...', this.modifiedBlocks.size, 'blocks');
    // TODO: Send changes to server
  }

  /**
   * Revert all changes
   */
  private revertAll(): void {
    console.log('[BlockEditor] Reverting all changes...');
    this.modifiedBlocks.clear();
    this.refreshContent();
    // TODO: Reload affected chunks from server
  }

  /**
   * Track modification for current block
   */
  private trackBlockModification(newBlockId: number): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;

    // Check if already tracked
    const existing = this.modifiedBlocks.get(key);

    if (!existing) {
      // New modification
      this.modifiedBlocks.set(key, {
        position: {
          x: this.selectedBlock.blockX,
          y: this.selectedBlock.blockY,
          z: this.selectedBlock.blockZ,
        },
        originalBlockId: this.selectedBlock.blockId,
        newBlockId: newBlockId,
        isNew: false,
        isDeleted: false,
      });
    } else {
      // Update existing modification
      existing.newBlockId = newBlockId;
    }

    console.log(`[BlockEditor] Tracked modification at ${key}: ${this.selectedBlock.blockId} -> ${newBlockId}`);

    // Refresh display to show modified count
    this.refreshContent();
  }

  /**
   * Revert single block
   */
  private revertBlock(): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;

    if (this.modifiedBlocks.has(key)) {
      this.modifiedBlocks.delete(key);
      console.log(`[BlockEditor] Reverted block at ${key}`);
      this.refreshContent();
    }
  }

  /**
   * Show editor
   */
  show(): void {
    if (this.isVisible) return;

    this.container.isVisible = true;
    this.isVisible = true;
    this.update();
  }

  /**
   * Hide editor
   */
  hide(): void {
    if (!this.isVisible) return;

    this.container.isVisible = false;
    this.isVisible = false;
  }

  /**
   * Toggle editor visibility
   */
  toggle(): void {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Check if editor is visible
   */
  getIsVisible(): boolean {
    return this.isVisible;
  }

  /**
   * Update editor content
   */
  update(): void {
    if (!this.isVisible) return;

    const selected = this.blockSelector.getSelectedBlock();

    if (this.hasSelectionChanged(selected)) {
      this.selectedBlock = selected;
      this.refreshContent();
    }
  }

  /**
   * Check if selection has changed
   */
  private hasSelectionChanged(newSelection: SelectedBlock | null): boolean {
    if (!this.selectedBlock && !newSelection) return false;
    if (!this.selectedBlock || !newSelection) return true;

    return (
      this.selectedBlock.blockX !== newSelection.blockX ||
      this.selectedBlock.blockY !== newSelection.blockY ||
      this.selectedBlock.blockZ !== newSelection.blockZ ||
      this.selectedBlock.blockId !== newSelection.blockId
    );
  }

  /**
   * Refresh editor content based on current tab
   */
  private refreshContent(): void {
    this.contentPanel.clearControls();

    switch (this.currentTab) {
      case EditorTab.BlockInfo:
        this.renderBlockInfo();
        break;
      case EditorTab.BlockEditor:
        this.renderBlockEditor();
        break;
      case EditorTab.BlockList:
        this.renderBlockList();
        break;
      case EditorTab.Changes:
        this.renderChanges();
        break;
    }
  }

  /**
   * Render Block Info tab (read-only)
   */
  private renderBlockInfo(): void {
    if (!this.selectedBlock) {
      this.addText('No block selected', '#888888');
      this.addText('Enable selection mode with "select on"', '#888888', 12);
      return;
    }

    const blockType = this.registry.getBlockByID(this.selectedBlock.blockId);

    if (!blockType) {
      this.addText(`Unknown block ID: ${this.selectedBlock.blockId}`, '#FF0000');
      return;
    }

    // Display block information (read-only)
    this.addSectionTitle('Block Information');
    this.addProperty('Position', `(${this.selectedBlock.blockX}, ${this.selectedBlock.blockY}, ${this.selectedBlock.blockZ})`);
    this.addProperty('Distance', `${this.selectedBlock.distance.toFixed(2)} blocks`);
    this.addSpacer();

    this.addSectionTitle('Block Type');
    this.addProperty('ID', `${blockType.id}`);
    this.addProperty('Name', blockType.name);
    if (blockType.displayName) {
      this.addProperty('Display Name', blockType.displayName);
    }
    this.addSpacer();

    this.addSectionTitle('Rendering');
    this.addProperty('Shape', this.getShapeName(blockType.shape));
    this.addProperty('Texture', this.getTextureInfo(blockType.texture));
    this.addProperty('Transparent', blockType.transparent ? 'Yes' : 'No');
    this.addProperty('Solid', blockType.solid !== false ? 'Yes' : 'No');
    this.addSpacer();

    if (blockType.options) {
      this.addSectionTitle('Block Options');
      if (blockType.options.material) {
        this.addProperty('Material', blockType.options.material);
      }
      if (blockType.options.fluid) {
        this.addProperty('Fluid', 'Yes');
      }
    }
  }

  /**
   * Render Block Editor tab (editable form)
   */
  private renderBlockEditor(): void {
    if (!this.selectedBlock) {
        this.addText('No block selected', '#888888');
        this.addText('Select a block or press "," to create new', '#888888', 12);
        return;
      }

      const blockType = this.registry.getBlockByID(this.selectedBlock.blockId);
      if (!blockType) {
        this.addText(`Unknown block ID: ${this.selectedBlock.blockId}`, '#FF0000');
        return;
      }

      // Position (read-only)
      this.addSectionTitle('Block Instance Editor');
      this.addProperty('Position', `(${this.selectedBlock.blockX}, ${this.selectedBlock.blockY}, ${this.selectedBlock.blockZ})`);
      this.addSpacer();

      // ============================================================
      // 1. BLOCK ID / TYPE SELECTOR (Dropdown)
      // ============================================================
      this.addLabel('Block Type:');
      const allBlocks = this.registry.getAllBlocks();
      const blockOptions = allBlocks.map(b => `${b.id}: ${b.name}`);
      const currentSelection = `${blockType.id}: ${blockType.name}`;

      // Simplified dropdown (using buttons for first few options)
      this.addDropdown(blockOptions, currentSelection, (newValue) => {
        const newBlockId = parseInt(newValue.split(':')[0]);
        if (!isNaN(newBlockId)) {
          this.trackBlockModification(newBlockId);
        }
      });
      this.addSpacer();

      // ============================================================
      // 2. EDGE OFFSETS (Collapsible)
      // ============================================================
      this.addCollapsibleHeader('Edge Offsets', this.edgeOffsetsExpanded, () => {
        this.edgeOffsetsExpanded = !this.edgeOffsetsExpanded;
        this.refreshContent();
      });

      if (this.edgeOffsetsExpanded) {
        this.addText('8 corners, 3 offset values (x,y,z) each: -127 to 128', '#888888', 11);
        this.addSpacer();

        // Load current edge offsets
        // Note: We need chunk reference to get edge offsets - simplified for now
        if (!this.currentEdgeOffsets) {
          this.currentEdgeOffsets = new Array(24).fill(0);
        }

        const cornerNames = [
          'Corner 0 (left-back-bottom)',
          'Corner 1 (right-back-bottom)',
          'Corner 2 (right-front-bottom)',
          'Corner 3 (left-front-bottom)',
          'Corner 4 (left-back-top)',
          'Corner 5 (right-back-top)',
          'Corner 6 (right-front-top)',
          'Corner 7 (left-front-top)'
        ];

        for (let i = 0; i < 8; i++) {
          this.addLabel(cornerNames[i]);

          // X offset
          this.addNumberInput(
            `  X offset:`,
            this.currentEdgeOffsets[i * 3],
            -127,
            128,
            (value) => {
              this.currentEdgeOffsets![i * 3] = value ?? 0;
            }
          );

          // Y offset
          this.addNumberInput(
            `  Y offset:`,
            this.currentEdgeOffsets[i * 3 + 1],
            -127,
            128,
            (value) => {
              this.currentEdgeOffsets![i * 3 + 1] = value ?? 0;
            }
          );

          // Z offset
          this.addNumberInput(
            `  Z offset:`,
            this.currentEdgeOffsets[i * 3 + 2],
            -127,
            128,
            (value) => {
              this.currentEdgeOffsets![i * 3 + 2] = value ?? 0;
            }
          );

          this.addSpacer();
        }

        // Clear edge offsets button
        const clearEdgeBtn = Button.CreateSimpleButton('clearEdgeOffsets', 'Clear All Edge Offsets');
        clearEdgeBtn.width = 1;
        clearEdgeBtn.height = '30px';
        clearEdgeBtn.color = '#FFFFFF';
        clearEdgeBtn.background = '#666600';
        clearEdgeBtn.onPointerClickObservable.add(() => {
          this.currentEdgeOffsets = null;
          this.refreshContent();
        });
        this.contentPanel.addControl(clearEdgeBtn);
        this.addSpacer();
      }

      // ============================================================
      // 3. MODIFIER (Collapsible)
      // ============================================================
      const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
      const tracked = this.modifiedBlocks.get(key);
      this.currentModifier = tracked?.modifier || null;

      this.addCollapsibleHeader('Modifier', this.modifierExpanded, () => {
        this.modifierExpanded = !this.modifierExpanded;
        this.refreshContent();
      });

      if (this.modifierExpanded) {
        this.addText('Override BlockType properties for this instance', '#888888', 11);
        this.addSpacer();

        // displayName
        this.addLabel('Display Name:');
        this.addInputField(
          this.currentModifier?.displayName || '',
          (newValue) => this.updateModifier('displayName', newValue || undefined)
        );

        // shape (dropdown)
        this.addLabel('Shape:');
        const shapeOptions = ['CUBE', 'CROSS', 'HASH', 'MODEL', 'GLASS', 'FLAT', 'SPHERE', 'COLUMN', 'ROUND_CUBE'];
        const currentShape = this.currentModifier?.shape !== undefined
          ? this.getShapeName(this.currentModifier.shape)
          : this.getShapeName(blockType.shape);
        this.addDropdown(shapeOptions, currentShape, (newValue) => {
          const shape = this.parseShapeName(newValue);
          this.updateModifier('shape', shape);
        });

        // texture (dropdown + free input)
        this.addLabel('Texture Path:');
        this.addInputField(
          this.currentModifier?.texture
            ? (Array.isArray(this.currentModifier.texture)
                ? this.currentModifier.texture.join(',')
                : this.currentModifier.texture)
            : '',
          (newValue) => this.updateModifier('texture', newValue || undefined)
        );

        // solid (checkbox)
        this.addCheckbox(
          'Solid',
          this.currentModifier?.solid ?? blockType.solid ?? true,
          (value) => this.updateModifier('solid', value)
        );

        // transparent (checkbox)
        this.addCheckbox(
          'Transparent',
          this.currentModifier?.transparent ?? blockType.transparent ?? false,
          (value) => this.updateModifier('transparent', value)
        );

        // unbreakable (checkbox)
        this.addCheckbox(
          'Unbreakable',
          this.currentModifier?.unbreakable ?? blockType.unbreakable ?? false,
          (value) => this.updateModifier('unbreakable', value)
        );

        // rotation (dropdown)
        this.addLabel('Rotation (degrees):');
        const rotationOptions = ['0', '45', '90', '135', '180', '225', '270', '315'];
        const currentRotation = this.currentModifier?.rotation?.toString() || '0';
        this.addDropdown(rotationOptions, currentRotation, (newValue) => {
          this.updateModifier('rotation', parseFloat(newValue));
        });

        // facing (dropdown)
        this.addLabel('Facing:');
        const facingOptions = ['0: Down', '1: Up', '2: North', '3: South', '4: East', '5: West'];
        const currentFacing = this.currentModifier?.facing !== undefined
          ? `${this.currentModifier.facing}: ...`
          : '0: Down';
        this.addDropdown(facingOptions, currentFacing, (newValue) => {
          const facing = parseInt(newValue.split(':')[0]);
          this.updateModifier('facing', facing);
        });

        // color (hex input)
        this.addLabel('Color (hex, e.g. #FF0000):');
        const colorHex = this.currentModifier?.color
          ? `#${this.currentModifier.color.map(c => c.toString(16).padStart(2, '0')).join('')}`
          : '';
        this.addInputField(colorHex, (newValue) => {
          if (newValue.startsWith('#') && newValue.length === 7) {
            const r = parseInt(newValue.substr(1, 2), 16);
            const g = parseInt(newValue.substr(3, 2), 16);
            const b = parseInt(newValue.substr(5, 2), 16);
            this.updateModifier('color', [r, g, b] as [number, number, number]);
          } else if (newValue === '') {
            this.updateModifier('color', undefined);
          }
        });

        // scale (x, y, z floats)
        this.addLabel('Scale:');
        const scaleX = this.currentModifier?.scale?.[0] ?? 1;
        const scaleY = this.currentModifier?.scale?.[1] ?? 1;
        const scaleZ = this.currentModifier?.scale?.[2] ?? 1;

        this.addNumberInput('  Scale X:', scaleX, 0.1, 10, (value) => {
          const current = this.currentModifier?.scale || [1, 1, 1];
          this.updateModifier('scale', [value ?? 1, current[1], current[2]] as [number, number, number]);
        });

        this.addNumberInput('  Scale Y:', scaleY, 0.1, 10, (value) => {
          const current = this.currentModifier?.scale || [1, 1, 1];
          this.updateModifier('scale', [current[0], value ?? 1, current[2]] as [number, number, number]);
        });

        this.addNumberInput('  Scale Z:', scaleZ, 0.1, 10, (value) => {
          const current = this.currentModifier?.scale || [1, 1, 1];
          this.updateModifier('scale', [current[0], current[1], value ?? 1] as [number, number, number]);
        });

        this.addSpacer();

        // ============================================================
        // 3.1 BLOCK OPTIONS (Nested Collapsible within Modifier)
        // ============================================================
        this.addCollapsibleHeader('  Block Options', this.blockOptionsExpanded, () => {
          this.blockOptionsExpanded = !this.blockOptionsExpanded;
          this.refreshContent();
        });

        if (this.blockOptionsExpanded) {
          this.addText('Override BlockOptions for this instance', '#888888', 11);
          this.addSpacer();

          const currentOptions = this.currentModifier?.options || {};

          // solid (checkbox)
          this.addCheckbox(
            '  Solid (options)',
            currentOptions.solid ?? blockType.options?.solid ?? true,
            (value) => {
              const newOptions = { ...currentOptions, solid: value };
              this.updateModifier('options', newOptions);
            }
          );

          // opaque (checkbox)
          this.addCheckbox(
            '  Opaque',
            currentOptions.opaque ?? blockType.options?.opaque ?? true,
            (value) => {
              const newOptions = { ...currentOptions, opaque: value };
              this.updateModifier('options', newOptions);
            }
          );

          // transparent (checkbox)
          this.addCheckbox(
            '  Transparent (options)',
            currentOptions.transparent ?? blockType.options?.transparent ?? false,
            (value) => {
              const newOptions = { ...currentOptions, transparent: value };
              this.updateModifier('options', newOptions);
            }
          );

          // material (dropdown)
          this.addLabel('  Material:');
          const materialOptions = ['solid', 'water', 'lava', 'barrier', 'gas'];
          const currentMaterial = currentOptions.material || blockType.options?.material || 'solid';
          this.addDropdown(materialOptions, currentMaterial, (newValue) => {
            const newOptions = { ...currentOptions, material: newValue as any };
            this.updateModifier('options', newOptions);
          });

          // fluid (checkbox)
          this.addCheckbox(
            '  Fluid',
            currentOptions.fluid ?? blockType.options?.fluid ?? false,
            (value) => {
              const newOptions = { ...currentOptions, fluid: value };
              this.updateModifier('options', newOptions);
            }
          );

          // fluidDensity (float)
          this.addNumberInput(
            '  Fluid Density:',
            currentOptions.fluidDensity ?? blockType.options?.fluidDensity,
            0,
            100,
            (value) => {
              const newOptions = { ...currentOptions, fluidDensity: value };
              this.updateModifier('options', newOptions);
            }
          );

          // viscosity (float)
          this.addNumberInput(
            '  Viscosity:',
            currentOptions.viscosity ?? blockType.options?.viscosity,
            0,
            1000,
            (value) => {
              const newOptions = { ...currentOptions, viscosity: value };
              this.updateModifier('options', newOptions);
            }
          );

          this.addSpacer();
        }

        // Clear modifier button
        const clearModifierBtn = Button.CreateSimpleButton('clearModifier', 'Clear All Modifiers');
        clearModifierBtn.width = 1;
        clearModifierBtn.height = '30px';
        clearModifierBtn.color = '#FFFFFF';
        clearModifierBtn.background = '#886600';
        clearModifierBtn.onPointerClickObservable.add(() => this.clearModifier());
        this.contentPanel.addControl(clearModifierBtn);
        this.addSpacer();
      }

      // ============================================================
      // ACTIONS
      // ============================================================
      // Revert Block button
      const revertBtn = Button.CreateSimpleButton('revertBlock', 'Revert This Block');
      revertBtn.width = 1;
      revertBtn.height = '30px';
      revertBtn.color = '#FFFFFF';
      revertBtn.background = '#AA0000';
      revertBtn.onPointerClickObservable.add(() => this.revertBlock());
      this.contentPanel.addControl(revertBtn);

      this.addSpacer();
      this.addText('Changes are tracked live', '#00FF00', 11);
      this.addText(`Modified blocks: ${this.modifiedBlocks.size}`, '#FFFF00', 11);
    }
  }

  /**
   * Render Block Type List tab
   */
  private renderBlockList(): void {
    this.addSectionTitle('All Registered Block-Types');

    const allBlocks = this.registry.getAllBlocks();

    if (allBlocks.length === 0) {
      this.addText('No block types registered', '#888888');
      return;
    }

    // Header
    this.addText('ID | Name | Shape | Material', '#00FF00', 12);
    this.addSpacer();

    // List all blocks
    for (const block of allBlocks) {
      const shape = this.getShapeName(block.shape);
      const material = block.options?.material || '-';
      this.addText(`${block.id} | ${block.name} | ${shape} | ${material}`, '#FFFFFF', 11);
    }
  }

  /**
   * Render Changes tab (modified block instances)
   */
  private renderChanges(): void {
    this.addSectionTitle('Modified Block-Instances');

    if (this.modifiedBlocks.size === 0) {
      this.addText('No changes pending', '#888888');
      this.addText('Edit blocks in the Block Editor tab', '#888888', 12);
      return;
    }

    this.addText(`Total changes: ${this.modifiedBlocks.size}`, '#FFFF00', 14);
    this.addSpacer();

    // Header
    this.addText('Position | Original → New | Status', '#00FF00', 12);
    this.addSpacer();

    // List all modified blocks
    for (const [key, modified] of this.modifiedBlocks.entries()) {
      const pos = `(${modified.position.x}, ${modified.position.y}, ${modified.position.z})`;

      // Get block type names
      const originalType = this.registry.getBlockByID(modified.originalBlockId);
      const newType = this.registry.getBlockByID(modified.newBlockId);

      const originalName = originalType ? originalType.name : `ID ${modified.originalBlockId}`;
      const newName = newType ? newType.name : `ID ${modified.newBlockId}`;

      // Status
      let status = 'Modified';
      let color = '#FFAA00';
      if (modified.isNew) {
        status = 'New';
        color = '#00FF00';
      } else if (modified.isDeleted) {
        status = 'Deleted';
        color = '#FF0000';
      }

      // Display line
      this.addText(`${pos}`, '#AAAAAA', 11);
      this.addText(`  ${originalName} → ${newName}`, '#FFFFFF', 11);
      this.addText(`  Status: ${status}`, color, 11);
      this.addSpacer();
    }

    // Action buttons
    const applyBtn = Button.CreateSimpleButton('applyChanges', 'Apply All Changes');
    applyBtn.width = 1;
    applyBtn.height = '35px';
    applyBtn.color = '#FFFFFF';
    applyBtn.background = '#00AA00';
    applyBtn.thickness = 1;
    applyBtn.fontSize = 14;
    applyBtn.onPointerClickObservable.add(() => this.applyAll());
    this.contentPanel.addControl(applyBtn);

    this.addSpacer();

    const revertBtn = Button.CreateSimpleButton('revertChanges', 'Revert All Changes');
    revertBtn.width = 1;
    revertBtn.height = '35px';
    revertBtn.color = '#FFFFFF';
    revertBtn.background = '#AA0000';
    revertBtn.thickness = 1;
    revertBtn.fontSize = 14;
    revertBtn.onPointerClickObservable.add(() => this.revertAll());
    this.contentPanel.addControl(revertBtn);
  }

  /**
   * Add label
   */
  private addLabel(text: string): void {
    const label = new TextBlock();
    label.text = text;
    label.color = '#AAAAAA';
    label.fontSize = 13;
    label.height = '20px';
    label.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    label.paddingTop = 5;
    this.contentPanel.addControl(label);
  }

  /**
   * Add input field with change tracking
   */
  private addInputField(value: string, onChange?: (newValue: string) => void): InputText {
    const input = new InputText();
    input.width = 1;
    input.height = '30px';
    input.color = '#FFFFFF';
    input.background = '#333333';
    input.text = value;
    input.fontSize = 13;
    input.thickness = 1;
    input.paddingLeft = 5;

    // Add change listener if provided
    if (onChange) {
      input.onTextChangedObservable.add(() => {
        onChange(input.text);
      });
    }

    this.contentPanel.addControl(input);
    return input;
  }

  /**
   * Get shape name from shape enum value
   */
  private getShapeName(shape: number): string {
    const shapes = ['CUBE', 'CROSS', 'HASH', 'MODEL', 'GLASS', 'FLAT', 'SPHERE', 'COLUMN', 'ROUND_CUBE'];
    return shapes[shape] || `Unknown (${shape})`;
  }

  /**
   * Get texture info string
   */
  private getTextureInfo(texture: string | string[]): string {
    if (Array.isArray(texture)) {
      return texture.length === 1 ? texture[0] : `Array (${texture.length} textures)`;
    }
    return texture;
  }

  /**
   * Add section title
   */
  private addSectionTitle(text: string): void {
    const title = new TextBlock();
    title.text = text;
    title.color = '#00FF00';
    title.fontSize = 16;
    title.height = '30px';
    title.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    title.paddingTop = 5;
    this.contentPanel.addControl(title);
  }

  /**
   * Add property row
   */
  private addProperty(label: string, value: string): void {
    const text = new TextBlock();
    text.text = `  ${label}: ${value}`;
    text.color = '#FFFFFF';
    text.fontSize = 14;
    text.height = '25px';
    text.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    text.textWrapping = true;
    text.resizeToFit = true;
    this.contentPanel.addControl(text);
  }

  /**
   * Add simple text
   */
  private addText(text: string, color: string = '#FFFFFF', fontSize: number = 14): void {
    const textBlock = new TextBlock();
    textBlock.text = text;
    textBlock.color = color;
    textBlock.fontSize = fontSize;
    textBlock.height = '25px';
    textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    textBlock.textWrapping = true;
    textBlock.resizeToFit = true;
    this.contentPanel.addControl(textBlock);
  }

  /**
   * Add spacer
   */
  private addSpacer(): void {
    const spacer = new TextBlock();
    spacer.text = '';
    spacer.height = '10px';
    this.contentPanel.addControl(spacer);
  }

  /**
   * Update modifier property
   */
  private updateModifier(property: keyof BlockModifier, value: any): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
    let tracked = this.modifiedBlocks.get(key);

    // Initialize tracked block if not exists
    if (!tracked) {
      tracked = {
        position: {
          x: this.selectedBlock.blockX,
          y: this.selectedBlock.blockY,
          z: this.selectedBlock.blockZ,
        },
        originalBlockId: this.selectedBlock.blockId,
        newBlockId: this.selectedBlock.blockId,
        isNew: false,
        isDeleted: false,
      };
      this.modifiedBlocks.set(key, tracked);
    }

    // Initialize modifier if not exists
    if (!tracked.modifier) {
      tracked.modifier = {};
    }

    // Update modifier property
    if (value === undefined) {
      delete tracked.modifier[property];
    } else {
      (tracked.modifier as any)[property] = value;
    }

    // Update current modifier reference
    this.currentModifier = tracked.modifier;

    console.log(`[BlockEditor] Updated modifier.${property} = ${value} for block at ${key}`);
    this.refreshContent();
  }

  /**
   * Clear all modifiers for current block
   */
  private clearModifier(): void {
    if (!this.selectedBlock) return;

    const key = `${this.selectedBlock.blockX},${this.selectedBlock.blockY},${this.selectedBlock.blockZ}`;
    const tracked = this.modifiedBlocks.get(key);

    if (tracked) {
      tracked.modifier = undefined;
      this.currentModifier = null;
      console.log(`[BlockEditor] Cleared modifiers for block at ${key}`);
      this.refreshContent();
    }
  }

  /**
   * Parse shape name to shape enum value
   */
  private parseShapeName(shapeName: string): number | undefined {
    if (!shapeName) return undefined;

    const shapeMap: { [key: string]: number } = {
      'CUBE': 0,
      'CROSS': 1,
      'HASH': 2,
      'MODEL': 3,
      'GLASS': 4,
      'FLAT': 5,
      'SPHERE': 6,
      'COLUMN': 7,
      'ROUND_CUBE': 8,
    };

    const normalized = shapeName.toUpperCase().trim();
    return shapeMap[normalized];
  }

  /**
   * Add dropdown selector
   */
  private addDropdown(options: string[], selectedValue: string, onChange: (newValue: string) => void): void {
    const dropdown = new SelectionPanel('dropdown');
    dropdown.width = 1;
    dropdown.height = '30px';
    dropdown.color = '#FFFFFF';
    dropdown.background = '#333333';
    dropdown.thickness = 1;

    // Add options (Simplified - using buttons since SelectionPanel is complex)
    // TODO: Implement proper dropdown with SelectionPanel
    const buttonContainer = new StackPanel();
    buttonContainer.isVertical = false;
    buttonContainer.width = 1;
    buttonContainer.height = '30px';

    for (const option of options.slice(0, 3)) { // Show first 3 options
      const btn = Button.CreateSimpleButton('opt_' + option, option);
      btn.width = '100px';
      btn.height = '28px';
      btn.color = option === selectedValue ? '#00FF00' : '#FFFFFF';
      btn.background = option === selectedValue ? '#003300' : '#222222';
      btn.fontSize = 11;
      btn.onPointerClickObservable.add(() => onChange(option));
      buttonContainer.addControl(btn);
    }

    this.contentPanel.addControl(buttonContainer);
  }

  /**
   * Add checkbox
   */
  private addCheckbox(label: string, checked: boolean, onChange: (value: boolean) => void): Checkbox {
    const container = new StackPanel();
    container.isVertical = false;
    container.width = 1;
    container.height = '30px';

    const checkbox = new Checkbox();
    checkbox.width = '20px';
    checkbox.height = '20px';
    checkbox.isChecked = checked;
    checkbox.color = '#FFFFFF';
    checkbox.background = '#333333';
    checkbox.onIsCheckedChangedObservable.add((value) => onChange(value));

    const labelText = new TextBlock();
    labelText.text = label;
    labelText.color = '#FFFFFF';
    labelText.fontSize = 13;
    labelText.width = 0.9;
    labelText.height = '30px';
    labelText.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    labelText.paddingLeft = 10;

    container.addControl(checkbox);
    container.addControl(labelText);
    this.contentPanel.addControl(container);

    return checkbox;
  }

  /**
   * Add collapsible section header
   */
  private addCollapsibleHeader(title: string, isExpanded: boolean, onToggle: () => void): void {
    const header = Button.CreateSimpleButton('header_' + title, (isExpanded ? '▼ ' : '▶ ') + title);
    header.width = 1;
    header.height = '35px';
    header.color = '#FFFF00';
    header.background = '#004400';
    header.thickness = 1;
    header.fontSize = 14;
    header.fontWeight = 'bold';
    header.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.paddingLeft = 10;
    header.onPointerClickObservable.add(onToggle);
    this.contentPanel.addControl(header);
  }

  /**
   * Add number input (for floats/ints with range)
   */
  private addNumberInput(label: string, value: number | undefined, min: number, max: number, onChange: (value: number | undefined) => void): void {
    this.addLabel(label);
    const input = this.addInputField(
      value !== undefined ? value.toString() : '',
      (newValue) => {
        if (newValue === '') {
          onChange(undefined);
        } else {
          const num = parseFloat(newValue);
          if (!isNaN(num)) {
            const clamped = Math.max(min, Math.min(max, num));
            onChange(clamped);
          }
        }
      }
    );
  }

  /**
   * Dispose editor
   */
  dispose(): void {
    this.container.dispose();
  }
}
