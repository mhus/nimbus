package de.mhus.nimbus.world.life.redis;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import de.mhus.nimbus.generated.types.EntityPathway;
import de.mhus.nimbus.world.life.config.WorldLifeProperties;
import de.mhus.nimbus.world.life.model.ChunkCoordinate;
import de.mhus.nimbus.world.shared.redis.WorldRedisMessagingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;

/**
 * Publishes entity pathways to world-player pods via Redis.
 * Channel: world:{worldId}:e.p
 *
 * Pathways are generated by SimulatorService and distributed to world-player pods.
 * Each world-player pod filters pathways based on session chunk registrations
 * and sends relevant pathways to connected clients.
 *
 * Message format:
 * {
 *   "pathways": [{EntityPathway}, ...],
 *   "affectedChunks": [{"cx": 6, "cz": -13}, ...]
 * }
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PathwayPublisher {

    private final WorldRedisMessagingService redisMessaging;
    private final WorldLifeProperties properties;
    private final ObjectMapper objectMapper;

    /**
     * Publish entity pathways to Redis for distribution to clients.
     *
     * @param pathways List of entity pathways
     * @param affectedChunks Chunks that contain these pathways
     */
    public void publishPathways(List<EntityPathway> pathways, Set<ChunkCoordinate> affectedChunks) {
        if (pathways == null || pathways.isEmpty()) {
            return;
        }

        try {
            ObjectNode message = objectMapper.createObjectNode();

            // Add pathways array
            ArrayNode pathwaysArray = message.putArray("pathways");
            for (EntityPathway pathway : pathways) {
                pathwaysArray.addPOJO(pathway);
            }

            // Add affected chunks array
            ArrayNode chunksArray = message.putArray("affectedChunks");
            for (ChunkCoordinate chunk : affectedChunks) {
                ObjectNode chunkObj = chunksArray.addObject();
                chunkObj.put("cx", chunk.getCx());
                chunkObj.put("cz", chunk.getCz());
            }

            // Publish to Redis
            String worldId = properties.getWorldId();
            String json = objectMapper.writeValueAsString(message);
            redisMessaging.publish(worldId, "e.p", json);

            log.debug("Published {} pathways to Redis, affecting {} chunks",
                    pathways.size(), affectedChunks.size());

        } catch (Exception e) {
            log.error("Failed to publish pathways to Redis: {} pathways", pathways.size(), e);
        }
    }

    /**
     * Publish a single pathway.
     *
     * @param pathway Entity pathway
     * @param affectedChunks Chunks affected by this pathway
     */
    public void publishPathway(EntityPathway pathway, Set<ChunkCoordinate> affectedChunks) {
        publishPathways(List.of(pathway), affectedChunks);
    }
}
