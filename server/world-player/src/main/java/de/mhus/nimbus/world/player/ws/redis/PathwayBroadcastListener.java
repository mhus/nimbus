package de.mhus.nimbus.world.player.ws.redis;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.mhus.nimbus.world.player.ws.BroadcastService;
import de.mhus.nimbus.world.shared.redis.WorldRedisMessagingService;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Listens for entity pathway updates from world-life pods.
 * Channel: world:{worldId}:e.p
 *
 * Receives pathways generated by world-life and distributes them to connected clients.
 * Uses BroadcastService to filter by chunk registration (only send pathways for
 * chunks that sessions have registered).
 *
 * Message format:
 * {
 *   "pathways": [{EntityPathway}, ...],
 *   "affectedChunks": [{"cx": 6, "cz": -13}, ...]
 * }
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PathwayBroadcastListener {

    private final WorldRedisMessagingService redisMessaging;
    private final BroadcastService broadcastService;
    private final ObjectMapper objectMapper;

    @PostConstruct
    public void subscribeToPathwayUpdates() {
        // Subscribe to "main" world (hardcoded for now, TODO: dynamic world subscription)
        redisMessaging.subscribe("main", "e.p", this::handlePathwayUpdate);
        log.info("Subscribed to entity pathway updates for world: main");
    }

    /**
     * Handle pathway update from world-life.
     *
     * @param topic Redis topic
     * @param message JSON message
     */
    private void handlePathwayUpdate(String topic, String message) {
        try {
            JsonNode data = objectMapper.readTree(message);

            JsonNode pathways = data.get("pathways");
            JsonNode affectedChunks = data.get("affectedChunks");

            if (pathways == null || !pathways.isArray()) {
                log.warn("Invalid pathway update: missing pathways array");
                return;
            }

            if (affectedChunks == null || !affectedChunks.isArray()) {
                log.warn("Invalid pathway update: missing affectedChunks array");
                return;
            }

            // Broadcast pathways to sessions for each affected chunk
            // BroadcastService will filter sessions by chunk registration
            for (JsonNode chunkNode : affectedChunks) {
                int cx = chunkNode.has("cx") ? chunkNode.get("cx").asInt() : 0;
                int cz = chunkNode.has("cz") ? chunkNode.get("cz").asInt() : 0;

                // Broadcast to all sessions that have this chunk registered
                int sentCount = broadcastService.broadcastToWorld(
                        "main",          // worldId
                        "e.p",           // messageType
                        pathways,        // data (pathways array)
                        null,            // originatingSessionId (none, from server)
                        cx,              // chunk X
                        cz               // chunk Z
                );

                log.trace("Broadcasted pathways to {} sessions for chunk ({}, {})",
                        sentCount, cx, cz);
            }

            log.debug("Handled pathway update: {} pathways, {} affected chunks",
                    pathways.size(), affectedChunks.size());

        } catch (Exception e) {
            log.error("Failed to handle pathway update: {}", message, e);
        }
    }
}
